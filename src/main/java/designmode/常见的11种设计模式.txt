
三个基本模式:
    1.单例 (Singleton)
    2.工厂 (Factory) - IOC
    3.代理 (Proxy) - AOP

七个常用模式:
    4.模板 (Template)
    ----------------------------
    5.外观 (Facade), 外观(门面)模式
    6.建造者 (Builder)
    ----------------------------
    7.适配器 (Adaptor)
    8.装饰者 (Decorator/Wrapper)
    ----------------------------
    9.策略 (Strategy)
    10.责任链 (Chain) - Mybatis,Dubbo,Servlet都用到了
    11.观察者 (Observe)

分类:
    创建型: 单例,工厂,建造者
    结构性: 代理,外观,适配器,装饰者
    行为型: 模板,策略,责任链,观察者

总结:
    工厂模式:
        简单工厂: 只【一个】具体工厂(基于一个基类), 生产【一个】基类的【多个】派生类
        普通工厂: 有【多个】具体工厂(基于一个基类), 每个工厂只生产【一个】基类的【一个】派生类
        抽象工厂: 有【多个】具体工厂(基于一个基类), 每个工厂生产【多个】基类的【一个】派生类
        总结: 区别在于工厂基类和工厂派生类, 对象基类和对象派生类的使用个数.

    代理模式:
        动态代理需要定义proxy,而静态代理不需要,静态代理新增接口复杂.
        JDK:
         概括: 基于实现
         原理: 实现回调接口(InvocationHandler)+反射机制
         缺点: 必须实现接口方法.
        CGLIB:
         概括: 基于继承(也可以强制让实现接口的类走代理)
         原理: 利用ASM开源包,对代理对象类的class文件加载进来,通过修改其字节码生成子类
         缺点: 因为是继承，默认不能代理 final 修饰的方法.
         注意: 虽然private方法无法通过继承类直接调用,但是 method.setAccessible(true) 可以让 private 方法被执行
              extend 是可以继承私有方法和属性的, 只是无法直接调用, 私有属性可以通过get.set方法, 私有方法只能通过 setAccessible
              经过测试:
              private,static 都无法被代理.

    模板模式:
        抽象出执行模板,定义抽象模板类和模板接口

    外观模式 VS 建造者模式
        外观模式是结构型, 直接通过类方法进行组装.
        建造模式是创建型, 通过调用统一接口进行组装.

    适配器 VS 装饰者
        适配器核心:implements, 相同点:扩展功能
        装饰者核心:extends, 相同点:扩展功能

    代理模式 VS 装饰者
        代理模式: 强调功能
        装饰者: 扩展功能, 支持层次嵌套(功能扩展)


